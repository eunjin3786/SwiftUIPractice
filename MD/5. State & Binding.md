# State & Binding

## 1. State

이 코드는 컴파일 에러가 납니다.

```swift
struct ContentView: View {
    var buttonState = false
    
    var body: some View {
        Button(action: {
            self.buttonState.toggle()
        }, label: {
            Text("버튼")
        })
    }
}
```



하지만 `buttonState` 에  `@State` 를 붙이면 컴파일 에러가 사라집니다.

```swift
struct ContentView: View {
    @State var buttonState = false
    
    var body: some View {
        Button(action: {
            self.buttonState.toggle()
        }, label: {
            Text("버튼")
        })
    }
}
```



그럼 State란 무엇일까요?!

간단히 말하자면 SwiftUI는 

**State가 바뀌면 View를 자동으로 업데이트 합니다. (즉 body를 전부 다시 그립니다.)**





아래 예제를 보겠습니다.

버튼을 누르면 name이라는 state를 바꿔줍니다.

state의 변화가 있을 때마다 body가 다시 그려지게 됩니다.

```swift
struct ContentView: View {
    @State var name = ""
    
    var body: some View {
        VStack(spacing: 50) {
            Text(name)
                .font(.largeTitle)
                .fontWeight(.bold)
            
            VStack(spacing: 20) {
                Button(action: {
                    self.name = "윌리엄"
                }, label: {
                    Text("윌리엄으로 이름 바꾸는 버튼")
                })
                
                Button(action: {
                    self.name = "벤틀리"
                }, label: {
                    Text("벤틀리로 이름 바꾸는 버튼")
                })
            }
        }
    }
}
```



![3xj4ga](https://user-images.githubusercontent.com/9502063/79884705-71288900-8430-11ea-95c6-fe28537cb70d.gif)











기존에 예제로 만들었던 List코드에도 `@State` 를 추가해보겠습니다.

```swift
struct ContentView: View {
    @State var friends: [Friend] = [Friend(name: "윌리엄", profileImageName: "baby"),
                                    Friend(name: "윌리엄", profileImageName: "baby"),
                                    Friend(name: "윌리엄", profileImageName: "baby")]

    var body: some View {
        NavigationView {
            List(friends) { friend in
                NavigationLink(destination: FriendDetailGridView(friend: friend)) {
                    FriendCell(friend: friend)
                }
            }
            .navigationBarTitle("리스트")
            .navigationBarItems(leading: navigationLeftBarItem,
                                trailing: navigationRightBarItem)
        }
    }
    
    var navigationLeftBarItem: some View {
        Button(action: {
            self.friends.removeLast()
        }) {
            Text("-").font(.largeTitle)
        }
    }
    
    var navigationRightBarItem: some View {
        Button(action: {
            let friend = Friend(name: "윌리엄", profileImageName: "baby")
            self.friends.append(friend)
        }) {
            Text("+").font(.largeTitle)
        }
    }
}
```



`@State` 를 붙인 변수가 업데이트되면 뷰가 자동으로 업데이트되는 것을 볼 수 있습니다 👍



![3xjdjg](https://user-images.githubusercontent.com/9502063/79888586-df247e80-8437-11ea-9461-8518f992a5a7.gif)



## 2. Binding

두가지 방향의 바인딩이 있습니다.

- View to ViewModel

- ViewModel to View

  

#### 2.1 View to ViewModel



<img width="674" alt="스크린샷 2020-04-29 오후 1 29 40" src="https://user-images.githubusercontent.com/9502063/80560869-7b90e700-8a1d-11ea-9eb0-78dacfb7f609.png">



View의 텍스트필드에 name과 age를 입력하면 ViewModel의 name과 age 프로퍼티가 업데이트 됩니다.



#### 2.2 ViewModel to View



<img width="697" alt="스크린샷 2020-04-29 오후 1 30 56" src="https://user-images.githubusercontent.com/9502063/80560925-aa0ec200-8a1d-11ea-8831-62ed8885c910.png">



ViewModel의 name과 age 프로퍼티가 업데이트되면 뷰의 텍스트필드의 텍스트가 업데이트 됩니다. 



#### 2.3 예제 - TextField

`TextField` 를 보겠습니다.

`TextField`의 이니셜라이저는 이렇게 생겼는데요, 

```swift
init<S>(_ title: S, text: Binding<String>, onEditingChanged: @escaping (Bool) -> Void = { _ in }, onCommit: @escaping () -> Void = {}) where S : StringProtocol
```



일단 title에 placeholder를 넣어주면 됩니다.

그리고 text는 `Binding<String>` 타입인 것을 유의해주세요-!



text의 타입에 맞게 state 프로퍼티에 달러($)를 붙여서 넣어줬습니다.



```swift
struct ContentView: View {
    @State private var name: String = ""
    var body: some View {
        VStack {
            TextField("Enter your name", text: $name)
            Spacer().frame(height: 30)
            Text(name)
        }
    }
}
```



위의 예제는 two-way binding이라고 할 수 있습니다.

- TextField에 text가 입력될때마다 name변수를 업데이트 시킵니다
- name변수가 업데이트 될때마다 뷰가 다시 그려집니다.



#### 2.4 예제 - Toggle

```swift
struct ContentView: View {
    @State private var showGreeting = true

    var body: some View {
        VStack {
            Toggle(isOn: $showGreeting) {
                Text("Show welcome message")
            }.padding()

            if showGreeting {
                Text("Hello World!")
            }
        }
    }
}

// https://www.hackingwithswift.com/quick-start/swiftui/how-to-create-a-toggle-switch
```



Toggle의 이니셜라이저는 이렇게 생겼습니다.

```swift
init(isOn: Binding<Bool>, @ViewBuilder label: () -> Label)
```

그래서 state property에 $를 붙여서 넣어줬습니다.



`Toggle` 도 two-way binding이라고 할 수 있습니다.

- toggle을 on/off로 바꿀 때마다 showGreeting변수를 업데이트 시킵니다.
- showGreeting변수가 업데이트될때마다 뷰가 다시 그려집니다.





#### 2.5 예제 - Custom View

위의 예제에서 Binding<> 타입을 통해 two-way binding을 한 것 처럼

custom view를 만들때도 주입받아야하는 프로퍼티에 @Binding을 붙이면 동일한 효과(?)를 기대할 수 있습니다.



이렇게 custom view를 만들면,

```swift
struct PlayView: View {
    @Binding var isPlay: Bool
    
    var body: some View {
        Button(action: {
            self.isPlay.toggle()
        }) {
            Text(isPlay ? "⏹" : "▶️")
                .font(.largeTitle)
        }
    }
}
```



사용하는 쪽에서 바인딩 타입의 프로퍼티를 넣어주게 되기 때문입니다.



<img width="497" alt="스크린샷 2020-04-29 오후 2 57 29" src="https://user-images.githubusercontent.com/9502063/80564782-c0bb1600-8a29-11ea-8594-b111377474df.png">





전체 코드를 보겠습니다.

```swift
struct ContentView: View {
    @State private var isPlay = false
    
    var body: some View {
        VStack {
            Text("노래제목")
                .font(.largeTitle)
                .foregroundColor(isPlay ? .green : .gray)
            
            Spacer()
                .frame(height: 20)
            
            Text("가수이름")
                .font(.title)
                .foregroundColor(isPlay ? .green : .gray)
            
            Spacer()
                .frame(height: 20)
            
            PlayView(isPlay: $isPlay)
        }
    }
}

struct PlayView: View {
    @Binding var isPlay: Bool
    
    var body: some View {
        Button(action: {
            self.isPlay.toggle()
        }) {
            Text(isPlay ? "⏹" : "▶️")
                .font(.largeTitle)
        }
    }
}
```



1) `PlayView`를 만들때,  `$isPlay` 를 넘겨줬습니다.

2) `PlayView` 의 버튼이 클릭될때마다 `isPlay` 값을 업데이트 시킵니다.

3) `isPlay` 값의 업데이트될때마다  `ContentView` 가 다시 그려집니다.



![3yp6uy](https://user-images.githubusercontent.com/9502063/80565031-6bcbcf80-8a2a-11ea-94d7-d179117a8ba6.gif)